from builtins import str
from datetime import date
import logging
import json
import os
from geopy.exc import GeopyError
import geopy.geocoders
import geopy.distance

from dateutil import relativedelta

from .models import Application
from .models import ApplicationDataCheck
from .statuses import ApplicationStatusCodes
from django.conf import settings
logger = logging.getLogger(__name__)
current_dir = os.getcwd()


def save_result(meet_requirements, application, check_sequence):
    try:
        q = ApplicationDataCheck.objects.filter(
            application_id=application.id, sequence=check_sequence
        ).first()
        if q:
            q.is_okay = meet_requirements
            q.save()
    except ApplicationDataCheck.DoesNotExist:
        return


def does_applicant_meet_age_requirements(dob):

    min_age = 21
    # set max age = 49 to prevent age over 50 years ex:(50 years 2 months)
    max_age = 49

    today = date.today()
    age = relativedelta.relativedelta(today, dob).years

    logger.info({
        'today': today,
        'dob': dob,
        'age': age,
        'action': 'checking_age_requirements'
    })

    meet_requirements = min_age <= age <= max_age

    if not meet_requirements:
        logger.warn({
            'today': today,
            'dob': dob,
            'age': age,
            'status': 'failed_age_requirements'
        })

    return meet_requirements


def true_owned_phone(application):
    return application.is_own_phone


def does_salary_meet_requirements(salary):

    min_salary = 3000000

    logger.info({
        'salary': salary,
        'action': 'checking_salary_requirements'
    })

    meet_requirements = salary >= min_salary

    if not meet_requirements:
        logger.warn({
            'salary': salary,
            'status': 'failed salary requirements'
        })
    return meet_requirements


def job_term_meet_requirements(job_start=None):

    min_months = 3

    today = date.today()
    if job_start is not None:
        job_term = relativedelta.relativedelta(today, job_start).months

        logger.info({
            'today': today,
            'job_start': job_start,
            'job_term': job_term,
            'action': 'checking_job_term_requirements'
        })

        meet_requirements = job_term >= min_months

        if not meet_requirements:
            logger.warn({
                'job_term': job_term,
                'status': 'failed_job_term_requirements'
            })

        return meet_requirements

    return False


def ktp_vs_areacode(application_ktp):

    form_ktp = str(application_ktp)
    ktp_area = form_ktp[0:6]

    filepath = os.path.join(current_dir, 'juloserver', 'julo', 'helpers', 'kode_wilayah.json')

    with open(filepath, 'r') as f:
        areas = json.loads(f.read())

    kode_kecamatan = []
    valid_area_code = False

    for area in areas:
        kode_kecamatan.append(str(area['kode_kecamatan']))

    for kode_kc in kode_kecamatan:
        if ktp_area == kode_kc:
            valid_area_code = True

    logger.info({
        'ktp_code': ktp_area,
        'action': 'checking ktp_vs_areacode'
    })

    return valid_area_code


def ktp_vs_dob(application):

    # get ktp id from application
    ktp_id = application.ktp
    ktp_dob = str(ktp_id)[6:12]

    dob = str(application.dob).replace('-', '')

    # slice the ktp number of dob code
    month = str(dob[4:6])
    day = str(dob[6:8])
    year = str(dob[2:4])

    # dob code generated by dob and rules
    dob_code = day + month + year

    gender = application.gender
    if gender.lower() == 'wanita':
        dob_code = str(int(day) + 40) + month + year

    logger.info({
        'ktp_dob': ktp_dob,
        'dob_code': dob_code,
        'action': 'checking ktp_vs_dob'
    })

    valid_ktp_dob = str(dob_code) == str(ktp_dob)

    if not valid_ktp_dob:
        logger.warn({
            'ktp_dob': ktp_dob,
            'dob_code': dob_code,
            'status': 'ktp_vs_dob_failed'
        })

    return valid_ktp_dob


def company_not_blacklist(company_name=None):

    if company_name is None:
        return True

    affixes = ['PT', 'CV']
    c_capital = company_name.upper()
    c_applicant = c_capital.replace(' ', '')

    # remove , and . if company name contained
    if ',' in c_applicant or '.' in c_applicant:
        c_applicant = c_applicant.replace(',', '')
        c_applicant = c_applicant.replace('.', '')

    # remove the affix from company_name on the formulir
    for affix in affixes:
        if c_applicant.startswith(affix) or c_applicant.endswith(affix):
            c_applicant = c_applicant.replace(affix, '')

    filepath = os.path.join(
        current_dir, 'juloserver', 'julo', 'helpers', 'blacklist_company.json')

    with open(filepath, 'r') as f:
        blacklist_companies = json.loads(f.read())

    not_blacklist = True

    for blacklist_company in blacklist_companies:
        data_to_formulir = blacklist_company.find(c_applicant) != -1
        formulir_to_data = c_applicant.find(blacklist_company) != -1

        if data_to_formulir and formulir_to_data:
            not_blacklist = False
            logger.info({
                'data_to_formulir_found': data_to_formulir,
                'formulir_to_data_found': formulir_to_data,
                'status': 'company_is_in_blacklist'
            })
            return not_blacklist

    return not_blacklist


def not_chinatrust_blacklist(application):

    name = application.fullname.upper()
    application_name = name.replace(' ', '')
    application_dob = application.dob
    application_ktp = application.ktp
    filepath = os.path.join(
        current_dir, 'juloserver', 'julo', 'helpers', 'chinatrust_blacklist.json')

    with open(filepath, 'r') as f:
        chinatrust_blacklist = json.loads(f.read())

    not_blacklist = True

    for data in chinatrust_blacklist:
        data_name = data['name'].replace(' ', '')

        if (
            application_name == data_name and
            str(application_dob) == data["dob"] and
            application_ktp == data["id"]
        ):
            not_blacklist = False
            logger.info({
                'application_name': application_name,
                'blacklist_name': data_name,
                'application_dob': application_dob,
                'blacklist_dob': data["dob"],
                'application_ktp': application_ktp,
                'blacklist_ktp': data["id"],
                'status': 'application_is_in_blacklist'
            })
            return not_blacklist

    return not_blacklist


def spouse_not_declined(application):
    spouse_name = application.spouse_name
    spouse_dob = application.spouse_dob
    statuses = [
        ApplicationStatusCodes.APPLICATION_DENIED,
        ApplicationStatusCodes.APPLICATION_FLAGGED_FOR_FRAUD
    ]

    found_applications = Application.objects.filter(fullname=spouse_name, dob=spouse_dob)
    not_declined = True

    for found_application in found_applications:
        decline_status = found_application.status in statuses
        if decline_status:
            not_declined = False

            logger.info({
                'application_id': application.id,
                'spouse_name': spouse_name,
                'spouse_dob': spouse_dob,
                'declined_application_fullname': found_application.fullname,
                'declined_application_dob': found_application.dob,
                'declined_application_status': found_application.status,
                'status': 'spouse_is_declined'
            })

            return not_declined

    logger.info({
        'application_id': application.id,
        'status': 'spouse_not_declined'
    })

    return not_declined


def kin_not_declined(application):

    kin_name = application.kin_name
    kin_dob = application.kin_dob
    statuses = [
        ApplicationStatusCodes.APPLICATION_DENIED,
        ApplicationStatusCodes.APPLICATION_FLAGGED_FOR_FRAUD
    ]

    found_applications = Application.objects.filter(fullname=kin_name, dob=kin_dob)
    not_declined = True

    for found_application in found_applications:
        decline_status = found_application.status in statuses
        if decline_status:
            not_declined = False

            logger.info({
                'application_id': application.id,
                'kin_name': kin_name,
                'kin_dob': kin_dob,
                'found_application_fullname_match': found_application.fullname,
                'found_application_dob_match': found_application.dob,
                'found_application_status': found_application.status,
                'status': 'kin_is_declined'
            })

            return not_declined

    logger.info({
        'application_id': application.id,
        'status': 'kin_not_declined'
    })

    return not_declined


def job_not_blacklist(application):
    banned_types = ['Pengusaha',
                    'Freelance',
                    'Ibu rumah tangga',
                    'Mahasiswa',
                    'Tidak bekerja']
    banned_jobs = ['Hukum / Security / Politik,Anggota Pemerintahan',
                   'Hukum / Security / Politik,Hakim / Jaksa / Pengacara',
                   'Hukum / Security / Politik,Notaris',
                   'Hukum / Security / Politik,Ormas',
                   'Hukum / Security / Politik,Pemuka Agama',
                   'Hukum / Security / Politik,Satpam',
                   'Hukum / Security / Politik,TNI / Polisi',
                   'Hukum / Security / Politik,Lainnya',
                   'Media,Kameraman',
                   'Media,Penulis / Editor',
                   'Media,Wartawan',
                   'Perbankan,Kolektor',
                   'Transportasi,Supir / Ojek',
                   'Transportasi,Pelaut / Staff Kapal / Nahkoda Kapal',
                   'Transportasi,Pilot / Staff Penerbangan',
                   'Transportasi,Masinis / Kereta Api']
    if application.job_type in banned_types:
        return False
    job = "{},{}".format(application.job_industry, application.job_description)
    return job not in banned_jobs


def fb_friends_gt_50(application):
    return application.facebook_data.friend_count > 50


def dob_match_fb_form(application):
    dob_fb = application.facebook_data.dob
    dob_form = application.dob
    return dob_fb == dob_form


def gender_match_fb_form(application):
    gender_mapping = {'male': 'Pria', 'female': 'Wanita'}
    gender_fb = gender_mapping.get(application.facebook_data.gender)
    if not gender_fb:
        return None
    gender_form = application.gender
    return gender_fb == gender_form


def email_match_fb_form(application):
    email_fb = application.facebook_data.email
    email_form = application.email
    return email_fb == email_form


def home_address_vs_gps(application):
    address = "{} {} {} {} {} {}".format(application.address_street_num,
                                         application.address_kelurahan,
                                         application.address_kecamatan,
                                         application.address_kabupaten,
                                         application.address_provinsi,
                                         application.address_kodepos)
    max_distance_apart = 100.0
    geocoder = geopy.geocoders.GoogleV3(api_key=settings.GOOGLE_MAPS_API_KEY)
    try:
        loc = geocoder.geocode(address)
    except GeopyError as gu:
        logger.error({
            'status': str(gu),
            'service': 'google_maps',
            'error_type': str(type(gu))
        })
        return None

    if not loc:
        logger.warn({
            'status': 'geolocation_not_found',
            'address': address
        })
        return None

    loc1 = (application.addressgeolocation.latitude, application.addressgeolocation.longitude)
    loc2 = (loc.latitude, loc.longitude)
    dist = geopy.distance.vincenty(loc1, loc2).meters
    logger.info({
        'address': address,
        'geolocation_from_address': loc2,
        'geolocation_from_gps': loc1,
        'distance_apart': dist,
        'application': application.id
    })
    return dist < max_distance_apart


def check_age_requirements(application, check_sequence):
    meet_requirements = does_applicant_meet_age_requirements(application.dob)
    save_result(meet_requirements, application, check_sequence)


def check_is_owned_phone(application, check_sequence):
    meet_requirements = true_owned_phone(application)
    save_result(meet_requirements, application, check_sequence)


def check_salary_requirements(application, check_sequence):
    meet_requirements = does_salary_meet_requirements(application.monthly_income)
    save_result(meet_requirements, application, check_sequence)


def check_jobterm_requirements(application, check_sequence):
    meet_requirements = job_term_meet_requirements(application.job_start)
    save_result(meet_requirements, application, check_sequence)


def check_ktp_vs_area(application, check_sequence):
    meet_requirements = ktp_vs_areacode(application.ktp)
    save_result(meet_requirements, application, check_sequence)


def check_ktp_vs_dob(application, check_sequence):
    meet_requirements = ktp_vs_dob(application)
    save_result(meet_requirements, application, check_sequence)


def check_company_not_blacklist(application, check_sequence):
    meet_requirements = company_not_blacklist(application.company_name)
    save_result(meet_requirements, application, check_sequence)


def check_applicant_not_blacklist(application, check_sequence):
    meet_requirements = not_chinatrust_blacklist(application)
    save_result(meet_requirements, application, check_sequence)


def check_spouse_not_declined(application, check_sequence):
    meet_requirements = spouse_not_declined(application)
    save_result(meet_requirements, application, check_sequence)


def check_kin_not_declined(application, check_sequence):
    meet_requirements = kin_not_declined(application)
    save_result(meet_requirements, application, check_sequence)


def check_job_not_blacklist(application, check_sequence):
    meet_requirements = job_not_blacklist(application)
    save_result(meet_requirements, application, check_sequence)


def check_fb_friends_gt_50(application, check_sequence):
    meet_requirements = fb_friends_gt_50(application)
    save_result(meet_requirements, application, check_sequence)


def check_dob_match_fb_form(application, check_sequence):
    meet_requirements = dob_match_fb_form(application)
    save_result(meet_requirements, application, check_sequence)


def check_gender_match_fb_form(application, check_sequence):
    meet_requirements = gender_match_fb_form(application)
    save_result(meet_requirements, application, check_sequence)


def check_email_match_fb_form(application, check_sequence):
    meet_requirements = email_match_fb_form(application)
    save_result(meet_requirements, application, check_sequence)


def check_home_address_vs_gps(application, check_sequence):
    meet_requirements = home_address_vs_gps(application)
    save_result(meet_requirements, application, check_sequence)
